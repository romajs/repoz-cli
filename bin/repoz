#!/usr/bin/env node

// 'use strict';

const fs = require('fs');
const os = require('os');
const program = require('commander');
const prompt = require('prompt');
const q = require('q');
const winston = require('winston');
const repoz = require('../lib/repoz');

const AT_READ = 0, AT_WRITE = 1;

const ACCESS_TYPES = {
	get : AT_READ,
	post : AT_WRITE,
	put : AT_WRITE,
	delete : AT_WRITE,
	list : AT_READ,
};

var d = os.homedir() + '/.repoz';
if(!fs.existsSync(d)) {
	fs.mkdirSync(d);
}

var f = d + '/credentials.json';
if(!fs.existsSync(f)) {
	fs.writeFileSync(f, '[]\n');
}

var credentials = readCredentials(f);

parseArgs(process.argv).then(function(args) {

	winston.info(args);

	getCredential(args.project, ACCESS_TYPES[args.command]).then(function(credential) {

		var r = repoz(args.project, credential.username, credential.password);
		var command = r[args.command];

		if(command === undefined) {
			winston.info('Command "%s" not found.', args.command);
			process.exit(1);
		}

		command.apply(this, [args.path, args.filepath]).then(function() {
			updateCredentials(credential);
			winston.info('done.');
			process.exit(0);
		}).catch(function(err) {
			winston.error('failed.', err);
			process.exit(1);
		});

	});

});

function parseArgs(argv) {

	var d = q.defer();

	program.version('0.0.1')
		.option('-p, --project [project]', 'Project')
		.arguments('<command> [path] [filepath]')
		.action(function (command, path, filepath) {
			d.resolve({
				project: program.project,
				command: command,
				path: path,
				filepath: filepath,
			});
		})
		.parse(argv);

	return d.promise;
}

function readCredentials(f) {
	return JSON.parse(fs.readFileSync(f));
}

function updateCredentials(credential) {

	var index, c = credentials.find(function(c, index) {
		return c.project === credential.project && c.username === credential.username;
	});

	if(!c) {
		credential.created_at = new Date().toISOString();
		credential.updated_at = null;
		credentials.push(credential);
	} else if(c.password !== credential.password || c.access_type !== credential.access_type) {
		c.password = credential.password;
		c.access_type = credential.access_type;
		c.updated_at = new Date().toISOString();
		credentials.splice(index, 1, c);
	} else {
		return;
	}

	fs.writeFileSync(f, JSON.stringify(credentials) + '\n');
	
	winston.info('credential saved.');
}

function getCredential(project, access_type) {

	var d = q.defer();

	findCredential(project, access_type).then(function(credential) {

		if(credential) {
			d.resolve(credential);
		} else {
			askCredential().then(function(credential) {
				credential.project = project;
				credential.access_type = access_type;
				d.resolve(credential);
			});
		}
	})

	return d.promise;
}

function findCredential(project, access_type) {

	var d = q.defer();

	var credential = credentials.find(function(credential) {
		return credential.project === project && credential.access_type >= access_type;
	})

	d.resolve(credential);

	return d.promise;
}

function askCredential() {

	var d = q.defer();

	var properties = [
		{ name: 'username' },
		{ name: 'password', hidden: true }
	];

	prompt.get(properties, function (err, credentials) {
		if (err) {
			d.reject(err);
		} else {
			d.resolve(credentials);
		}
	});

	prompt.start();

	return d.promise;
}